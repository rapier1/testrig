.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::SSH2::Channel 3pm"
.TH Net::SSH2::Channel 3pm "2016-05-23" "perl v5.20.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::SSH2::Channel \- SSH2 channel object
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  my $chan = $ssh2\->channel()
\&    or $ssh2\->die_with_error;
\&
\&  $chan\->exec("ls \-ld /usr/local/libssh2*")
\&    or $ssh2\->die_with_error;
\&
\&  $chan\->send_eof;
\&
\&  while (<$chan>) {
\&    print "line read: $_";
\&  }
\&
\&  print "exit status: " . $chan\->exit_status . "\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A channel object is created by the Net::SSH2 \f(CW\*(C`channel\*(C'\fR method.  As well
as being an object, it is also a tied filehandle.
.SS "setenv ( key, value ... )"
.IX Subsection "setenv ( key, value ... )"
Sets remote environment variables. Note that most servers do not allow
environment variables to be freely set.
.PP
Pass in a list of keys and values with the values to set.
.PP
It returns a true value if all the given environment variables were
correctly set.
.SS "blocking ( flag )"
.IX Subsection "blocking ( flag )"
Enable or disable blocking.
.PP
Note that this is currently implemented in libssh2 by setting a
per-session flag. It's equivalent to Net::SSH2::blocking.
.SS "eof"
.IX Subsection "eof"
Returns true if the remote server sent an \s-1EOF.\s0
.SS "send_eof"
.IX Subsection "send_eof"
Sends an \s-1EOF\s0 to the remote side.
.PP
After an \s-1EOF\s0 has been sent, no more data may be
sent to the remote process \f(CW\*(C`STDIN\*(C'\fR channel.
.PP
Note that if a \s-1PTY\s0 was requested for the channel, the \s-1EOF\s0 may be
ignored by the remote server. See \*(L"pty\*(R".
.SS "close"
.IX Subsection "close"
Close the channel (happens automatically on object destruction).
.SS "wait_closed"
.IX Subsection "wait_closed"
Wait for a remote close event.
.PP
In order to avoid a bug in libssh2 this method discards any unread
data queued in the channel.
.SS "exit_status"
.IX Subsection "exit_status"
Returns the channel's program exit status.
.PP
This method blocks until the remote side closes the channel.
.SS "pty ( terminal [, modes [, width [, height ]]] )"
.IX Subsection "pty ( terminal [, modes [, width [, height ]]] )"
Request a terminal on a channel.
.PP
\&\f(CW\*(C`terminal\*(C'\fR is the type of emulation (e.g. vt102, ansi,
etc...). \f(CW\*(C`modes\*(C'\fR are the terminal mode modifiers.
.PP
If provided, \f(CW\*(C`width\*(C'\fR and \f(CW\*(C`height\*(C'\fR are the width and height in
characters (defaults to 80x24); if negative their absolute values
specify width and height in pixels.
.SS "pty_size ( width, height )"
.IX Subsection "pty_size ( width, height )"
Request a terminal size change on a channel. \f(CW\*(C`width\*(C'\fR and \f(CW\*(C`height\*(C'\fR are the
width and height in characters; if negative their absolute values specify
width and height in pixels.
.SS "ext_data ( mode )"
.IX Subsection "ext_data ( mode )"
Set extended data handling mode:
.IP "normal (default)" 4
.IX Item "normal (default)"
Keep data in separate channels; \f(CW\*(C`STDERR\*(C'\fR is read separately.
.IP "ignore" 4
.IX Item "ignore"
Ignore all extended data.
.IP "merge" 4
.IX Item "merge"
Merge into the regular channel.
.SS "process ( request, message )"
.IX Subsection "process ( request, message )"
Start a process on the channel.  See also shell, exec, subsystem.
.PP
Note that only one invocation of \f(CW\*(C`process\*(C'\fR or any of the shortcuts
\&\f(CW\*(C`shell\*(C'\fR, \f(CW\*(C`exec\*(C'\fR or \f(CW\*(C`subsystem\*(C'\fR is allowed per channel. In order to
run several commands, shells or/and subsystems, a new \f(CW\*(C`Channel\*(C'\fR
instance must be used for every one.
.PP
Alternatively, it is also possible to launch a remote shell (using
shell) and simulate the user interaction printing commands to its
\&\f(CW\*(C`stdin\*(C'\fR stream and reading data back from its \f(CW\*(C`stdout\*(C'\fR and
\&\f(CW\*(C`stderr\*(C'\fR. But this approach should be avoided if possible; talking to
a shell is difficult and, in general, unreliable.
.SS "shell"
.IX Subsection "shell"
Start a shell on the remote host (calls \f(CW\*(C`process("shell")\*(C'\fR).
.SS "exec ( command )"
.IX Subsection "exec ( command )"
Execute the command on the remote host (calls \f(CW\*(C`process("exec", command)\*(C'\fR).
.PP
Note that the given command is parsed by the remote shell; it should
be properly quoted, specially when passing data from untrusted sources.
.SS "subsystem ( name )"
.IX Subsection "subsystem ( name )"
Run subsystem on the remote host (calls \f(CW\*(C`process("subsystem", name)\*(C'\fR).
.SS "read ( buffer, max_size [, ext ] )"
.IX Subsection "read ( buffer, max_size [, ext ] )"
Attempts to read up to \f(CW\*(C`max_size\*(C'\fR bytes from the channel into \f(CW\*(C`buffer\*(C'\fR. If
\&\f(CW\*(C`ext\*(C'\fR is true, reads from the extended data channel (\f(CW\*(C`STDERR\*(C'\fR).
.PP
The method returns as soon as some data is available, even if the
given size has not been reached.
.PP
Returns number of bytes read or \f(CW\*(C`undef\*(C'\fR on failure. Note that 0 is a
valid return code.
.SS "read2 ( [max_size] )"
.IX Subsection "read2 ( [max_size] )"
Attempts to read from both the ordinary (stdout) and the extended
(stderr) channel streams.
.PP
Returns two scalars with the data read both from stdout and stderr. It
returns as soon as some data is available and any of the returned
values may be an empty string.
.PP
When some error happens it returns the empty list.
.PP
Example:
.PP
.Vb 11
\&  my ($out, $err) = (\*(Aq\*(Aq, \*(Aq\*(Aq);
\&  while (!$channel\->eof) {
\&      if (my ($o, $e) = $channel\->read2) {
\&          $out .= $o;
\&          $err .= $e;
\&      }
\&      else {
\&          $ssh2\->die_with_error;
\&      }
\&  }
\&  print "STDOUT:\en$out\enSTDERR:\en$err\en";
.Ve
.SS "readline ( [ext [, eol ] ] )"
.IX Subsection "readline ( [ext [, eol ] ] )"
Reads the next line from the selected stream (\f(CW\*(C`ext\*(C'\fR defaults to 0:
stdout).
.PP
\&\f(CW$/\fR is used as the end of line marker when \f(CW\*(C`eol\*(C'\fR is \f(CW\*(C`undef\*(C'\fR.
.PP
In list context reads and returns all the remaining lines until some
read error happens or the remote side sends an eof.
.PP
Note that this method is only safe when the complementary stream
(e.g. \f(CW\*(C`!ext\*(C'\fR) is guaranteed to not generate data or when \*(L"ext_data\*(R"
has been used to discard or merge it; otherwise it may hang. This is a
limitation of libssh2 that hopefully would be removed in a future
release, in the meantime you are advised to use read2 instead.
.SS "getc( [ext] )"
.IX Subsection "getc( [ext] )"
Reads and returns the next character from the selected stream.
.PP
Returns \f(CW\*(C`undef\*(C'\fR on error.
.PP
Note that due to some libssh2 quirks, the return value can be the
empty string which may indicate an \s-1EOF\s0 condition (but not
always!). See \*(L"eof\*(R".
.SS "write ( buffer )"
.IX Subsection "write ( buffer )"
Send the data in \f(CW\*(C`buffer\*(C'\fR through the channel. Returns number of
bytes written, undef on failure.
.PP
In versions of this module prior to 0.57, when working in non-blocking
mode, the would-block condition was signaled by returning
\&\f(CW\*(C`LIBSSH2_ERROR_EAGAIN\*(C'\fR (a negative number) while leaving the session
error status unset. From version 0.59, \f(CW\*(C`undef\*(C'\fR is returned and the
session error status is set to \f(CW\*(C`LIBSSH2_ERROR_EAGAIN\*(C'\fR as for any
other error.
.PP
In non-blocking mode, if \f(CW\*(C`write\*(C'\fR fails with a \f(CW\*(C`LIBSSH2_ERROR_EAGAIN\*(C'\fR
error, no other operation must be invoked over any object in the same
\&\s-1SSH\s0 session besides \*(L"sock\*(R" and blocking_directions.
.PP
Once the socket becomes ready again, the exact same former \f(CW\*(C`write\*(C'\fR
call, with exactly the same arguments must be invoked.
.PP
Failing to do that would result in a corrupted \s-1SSH\s0 session. This is a
limitation in libssh2.
.SS "flush ( [ ext ] )"
.IX Subsection "flush ( [ ext ] )"
Flushes the channel; if \f(CW\*(C`ext\*(C'\fR is present and set, flushes extended
data channel. Returns number of bytes flushed, \f(CW\*(C`undef\*(C'\fR on error.
.SS "exit_signal"
.IX Subsection "exit_signal"
Returns the name of exit signal from the remote command.
.PP
In list context returns also the error message and a language tag,
though as of libssh2 1.7.0, those values are always undef.
.PP
This method blocks until the remote side closes the channel.
.SS "exit_signal_number"
.IX Subsection "exit_signal_number"
Converts the signal name to a signal number using the local mapping
(which may be different to the remote one if the operating systems
differ).
.SS "window_read"
.IX Subsection "window_read"
Returns the number of bytes which the remote end may send without
overflowing the window limit.
.PP
In list context it also returns the number of bytes that are
immediately available for read and the size of the initial window.
.SS "window_write"
.IX Subsection "window_write"
Returns the number of bytes which may be safely written to the channel
without blocking at the \s-1SSH\s0 level. In list context it also returns the
size of the initial window.
.PP
Note that this method doesn't take into account the \s-1TCP\s0 connection
being used under the hood. Getting a positive integer back from this
method does not guarantee that such number of bytes could be written
to the channel without blocking the \s-1TCP\s0 connection.
.SS "receive_window_adjust (adjustment [, force])"
.IX Subsection "receive_window_adjust (adjustment [, force])"
Adjust the channel receive window by the given \f(CW\*(C`adjustment\*(C'\fR bytes.
.PP
If the amount to be adjusted is less than \f(CW\*(C`LIBSSH2_CHANNEL_MINADJUST\*(C'\fR
and force is false the adjustment amount will be queued for a later
packet.
.PP
On success returns the new size of the receive window. On failure it
returns \f(CW\*(C`undef\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Net::SSH2.
