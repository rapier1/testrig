.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Net::SSH2 3pm"
.TH Net::SSH2 3pm "2019-03-17" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::SSH2 \- Support for the SSH 2 protocol via libssh2.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Net::SSH2;
\&
\&  my $ssh2 = Net::SSH2\->new();
\&
\&  $ssh2\->connect(\*(Aqexample.com\*(Aq) or $ssh2\->die_with_error;
\&
\&  $ssh\->check_hostkey(\*(Aqask\*(Aq) or $ssh2\->die_with_error;
\&
\&  if ($ssh2\->auth_keyboard(\*(Aqfizban\*(Aq)) {
\&      my $chan = $ssh2\->channel();
\&      $chan\->exec(\*(Aqprogram\*(Aq);
\&
\&      my $sftp = $ssh2\->sftp();
\&      my $fh = $sftp\->open(\*(Aq/etc/passwd\*(Aq) or $sftp\->die_with_error;
\&      print $_ while <$fh>;
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Net::SSH2 is a Perl interface to the libssh2
(<http://www.libssh2.org>) library.  It supports the \s-1SSH2\s0 protocol
(there is no support for \s-1SSH1\s0) with all of the key exchanges, ciphers,
and compression of libssh2.
.PP
Even if the module can be compiled and linked against very old
versions of the library, nothing below 1.5.0 should really be used
(older versions were quite buggy and unreliable) and version 1.7.0 or
later is recommended.
.SS "Error handling"
.IX Subsection "Error handling"
Unless otherwise indicated, methods return a true value on success and
\&\f(CW\*(C`undef\*(C'\fR on failure; use the \*(L"error\*(R" method to get extended error
information.
.PP
\&\fBImportant\fR: methods in Net::SSH2 not backed by libssh2 functions
(i.e. \*(L"check_hostkey\*(R" or \s-1SCP\s0 related methods) require
libssh2 1.7.0 or later in order to set the error state. That means
that after any of those methods fails, \*(L"error\*(R" would not return the
real code but just some bogus result when an older version of the
library is used.
.SS "Typical usage"
.IX Subsection "Typical usage"
The typical usage order is as follows:
.IP "1." 4
Create the \s-1SSH2\s0 object calling \*(L"new\*(R".
.IP "2." 4
Configure the session if required. For instance, enabling compression
or picking some specific encryption methods.
.IP "3." 4
Establish the \s-1SSH\s0 connection calling the method \*(L"connect\*(R".
.IP "4." 4
Check the remote host public key calling \*(L"check_hostkey\*(R".
.IP "5." 4
Authenticate calling the required authentication methods.
.IP "6." 4
Call \*(L"channel\*(R" and related methods to create new bidirectional
communication channels over the \s-1SSH\s0 connection.
.IP "7." 4
Close the connection letting the Net::SSH2 object go out of scope or
calling \*(L"disconnect\*(R" explicitly.
.SH "CONSTANTS"
.IX Header "CONSTANTS"
All the constants defined in libssh2 can be imported from
Net::SSH2.
.PP
For instance:
.PP
.Vb 3
\&   use Net::SSH2 qw(LIBSSH2_CHANNEL_EXTENDED_DATA_MERGE
\&                    LIBSSH2_CHANNEL_FLUSH_ALL
\&                    LIBSSH2_HOSTKEY_POLICY_ASK);
.Ve
.PP
Though note that most methods accept the uncommon part of the
constant name as a string. For instance the following two method calls
are equivalent:
.PP
.Vb 2
\&    $channel\->ext_data(LIBSSH2_CHANNEL_EXTENDED_DATA_MERGE);
\&    $channel\->ext_data(\*(Aqmerge\*(Aq);
.Ve
.PP
Tags can be used to import the following constant subsets:
.PP
.Vb 2
\&  callback channel error socket trace hash method
\&  disconnect policy fx fxf sftp
.Ve
.PP
The tag \f(CW\*(C`all\*(C'\fR can also be used to import all of them.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "new ( %options )"
.el .SS "new ( \f(CW%options\fP )"
.IX Subsection "new ( %options )"
Create new Net::SSH2 object representing a \s-1SSH\s0 session.
.PP
The accepted options are as follows:
.IP "timeout" 4
.IX Item "timeout"
Sets the default timeout in milliseconds. See \*(L"timeout\*(R".
.IP "trace" 4
.IX Item "trace"
Sets tracing. See \*(L"trace\*(R".
.Sp
Example:
.Sp
.Vb 1
\&    my $ssh2 = Net::SSH2\->new(trace => \-1);
.Ve
.Sp
Note that tracing requires a version of libssh2 compiled with debugging support.
.IP "debug" 4
.IX Item "debug"
Enable debugging. See \*(L"debug\*(R".
.IP "compress" 4
.IX Item "compress"
Sets flag \f(CW\*(C`LIBSSH2_FLAG_COMPRESS\*(C'\fR. See \*(L"flag\*(R".
.IP "sigpipe" 4
.IX Item "sigpipe"
Sets flag \f(CW\*(C`LIBSSH2_FLAG_SIGPIPE\*(C'\fR. See \*(L"flag\*(R".
.SS "banner ( text )"
.IX Subsection "banner ( text )"
Set the \s-1SSH2\s0 banner text sent to the remote host (prepends required \*(L"\s-1SSH\-2.0\-\*(R"\s0).
.SS "version"
.IX Subsection "version"
In scalar context, returns libssh2 version/patch e.g. 0.18 or \*(L"0.18.0\-20071110\*(R".
In list context, returns that version plus the numeric version (major, minor,
and patch, each encoded as 8 bits, e.g. 0x001200 for version 0.18) and the
default banner text (e.g. \*(L"\s-1SSH\-2\s0.0\-libssh2_0.18.0\-20071110\*(R").
.SS "error"
.IX Subsection "error"
Returns the last error code. In list context,
returns (code, error name, error string).
.PP
Note that the returned error value is only meaningful after some other
method indicates an error by returning false.
.SS "die_with_error ( [message] )"
.IX Subsection "die_with_error ( [message] )"
Calls \f(CW\*(C`die\*(C'\fR with the given message and the error information from the
object appended.
.PP
For instance:
.PP
.Vb 4
\&  $ssh2\->connect("ajhkfhdklfjhklsjhd", 22)
\&      or $ssh2\->die_with_error;
\&  # dies as:
\&  #    Unable to connect to remote host: Invalid argument (\-1 LIBSSH2_ERROR_SOCKET_NONE)
.Ve
.SS "sock"
.IX Subsection "sock"
Returns a reference to the underlying IO::Socket object (usually a
derived class as IO::Socket::IP or IO::Socket::INET), or
\&\f(CW\*(C`undef\*(C'\fR if not yet connected.
.SS "trace"
.IX Subsection "trace"
Calls \f(CW\*(C`libssh2_trace\*(C'\fR with supplied bitmask. In order to enable all
tracing pass \f(CW\*(C`\-1\*(C'\fR as follows:
.PP
.Vb 1
\&    $ssh2\->trace(\-1);
.Ve
.PP
A version of libssh2 compiled with tracing support is required.
.SS "timeout ( timeout_ms )"
.IX Subsection "timeout ( timeout_ms )"
Enables a global timeout (in milliseconds) which will affect every
action (requires libssh2 1.2.9 or later).
.PP
By default, or if you set the timeout to zero, Net::SSH2 has no
timeout.
.PP
Note that timeout errors may leave the \s-1SSH\s0 connection in an
inconsistent state and further operations may fail or behave
incorrectly. Actually, some methods are able to recover after a
timeout error and others are not.
.PP
\&\fIDon't hesitate to report any issue you encounter related to this so
that it can be fixed or at least, documented!\fR
.SS "method ( type [, values... ] )"
.IX Subsection "method ( type [, values... ] )"
Sets or gets a method preference. For get, pass in the type only; to
set, pass in either a list of values or a comma-separated
string. Values can only be queried after the session is connected.
.PP
The following methods can be set or queried:
.IP "\s-1LIBSSH2_METHOD_KEX\s0" 4
.IX Item "LIBSSH2_METHOD_KEX"
Key exchange method names. Supported values:
.RS 4
.IP "diffie\-hellman\-group1\-sha1" 4
.IX Item "diffie-hellman-group1-sha1"
Diffie-Hellman key exchange with \s-1SHA\-1\s0 as hash, and Oakley Group 2 (see \s-1RFC
2409\s0).
.IP "diffie\-hellman\-group14\-sha1" 4
.IX Item "diffie-hellman-group14-sha1"
Diffie-Hellman key exchange with \s-1SHA\-1\s0 as hash, and Oakley Group 14 (see \s-1RFC
3526\s0).
.IP "diffie\-hellman\-group\-exchange\-sha1" 4
.IX Item "diffie-hellman-group-exchange-sha1"
Diffie-Hellman key exchange with \s-1SHA\-1\s0 as hash, using a safe\-prime/generator
pair (chosen by server) of arbitrary strength (specified by client) (see \s-1IETF\s0
draft secsh-dh-group-exchange).
.RE
.RS 4
.RE
.IP "\s-1LIBSSH2_METHOD_HOSTKEY\s0" 4
.IX Item "LIBSSH2_METHOD_HOSTKEY"
Public key algorithms. Supported values:
.RS 4
.IP "ssh-dss" 4
.IX Item "ssh-dss"
Based on the Digital Signature Standard (\s-1FIPS\-186\-2\s0).
.IP "ssh-rsa" 4
.IX Item "ssh-rsa"
Based on PKCS#1 (\s-1RFC 3447\s0).
.RE
.RS 4
.RE
.IP "\s-1LIBSSH2_METHOD_CRYPT_CS\s0" 4
.IX Item "LIBSSH2_METHOD_CRYPT_CS"
Encryption algorithm from client to server. Supported algorithms:
.RS 4
.IP "aes256\-cbc" 4
.IX Item "aes256-cbc"
\&\s-1AES\s0 in \s-1CBC\s0 mode, with 256\-bit key.
.IP "rijndael\-cbc@lysator.liu.se" 4
.IX Item "rijndael-cbc@lysator.liu.se"
Alias for aes256\-cbc.
.IP "aes192\-cbc" 4
.IX Item "aes192-cbc"
\&\s-1AES\s0 in \s-1CBC\s0 mode, with 192\-bit key.
.IP "aes128\-cbc" 4
.IX Item "aes128-cbc"
\&\s-1AES\s0 in \s-1CBC\s0 mode, with 128\-bit key.
.IP "blowfish-cbc" 4
.IX Item "blowfish-cbc"
Blowfish in \s-1CBC\s0 mode.
.IP "arcfour" 4
.IX Item "arcfour"
\&\s-1ARCFOUR\s0 stream cipher.
.IP "cast128\-cbc" 4
.IX Item "cast128-cbc"
\&\s-1CAST\-128\s0 in \s-1CBC\s0 mode.
.IP "3des\-cbc" 4
.IX Item "3des-cbc"
Three-key 3DES in \s-1CBC\s0 mode.
.IP "none" 4
.IX Item "none"
No encryption.
.RE
.RS 4
.RE
.IP "\s-1LIBSSH2_METHOD_CRYPT_SC\s0" 4
.IX Item "LIBSSH2_METHOD_CRYPT_SC"
Encryption algorithm from server to client. See the
\&\f(CW\*(C`LIBSSH2_METHOD_CRYPT_CS\*(C'\fR entry above for supported algorithms.
.IP "\s-1LIBSSH2_METHOD_MAC_CS\s0" 4
.IX Item "LIBSSH2_METHOD_MAC_CS"
Message Authentication Code (\s-1MAC\s0) algorithms from client to server. Supported
values:
.RS 4
.IP "hmac\-sha1" 4
.IX Item "hmac-sha1"
\&\s-1SHA\-1\s0 with 20\-byte digest and key length.
.IP "hmac\-sha1\-96" 4
.IX Item "hmac-sha1-96"
\&\s-1SHA\-1\s0 with 20\-byte key length and 12\-byte digest length.
.IP "hmac\-md5" 4
.IX Item "hmac-md5"
\&\s-1MD5\s0 with 16\-byte digest and key length.
.IP "hmac\-md5\-96" 4
.IX Item "hmac-md5-96"
\&\s-1MD5\s0 with 16\-byte key length and 12\-byte digest length.
.IP "hmac\-ripemd160" 4
.IX Item "hmac-ripemd160"
\&\s-1RIPEMD\-160\s0 algorithm with 20\-byte digest length.
.IP "hmac\-ripemd160@openssh.com" 4
.IX Item "hmac-ripemd160@openssh.com"
Alias for hmac\-ripemd160.
.IP "none" 4
.IX Item "none"
No encryption.
.RE
.RS 4
.RE
.IP "\s-1LIBSSH2_METHOD_MAC_SC\s0" 4
.IX Item "LIBSSH2_METHOD_MAC_SC"
Message Authentication Code (\s-1MAC\s0) algorithms from server to client. See
\&\s-1LIBSSH2_METHOD_MAC_CS\s0 for supported algorithms.
.IP "\s-1LIBSSH2_METHOD_COMP_CS\s0" 4
.IX Item "LIBSSH2_METHOD_COMP_CS"
Compression methods from client to server. Supported values:
.RS 4
.IP "zlib" 4
.IX Item "zlib"
The \*(L"zlib\*(R" compression method as described in \s-1RFC 1950\s0 and \s-1RFC 1951.\s0
.IP "none" 4
.IX Item "none"
No compression
.RE
.RS 4
.RE
.IP "\s-1LIBSSH2_METHOD_COMP_SC\s0" 4
.IX Item "LIBSSH2_METHOD_COMP_SC"
Compression methods from server to client. See
\&\s-1LIBSSH2_METHOD_COMP_CS\s0 for supported compression methods.
.SS "connect ( handle | host [, port])"
.IX Subsection "connect ( handle | host [, port])"
The argument combinations accepted are as follows:
.ie n .IP "a glob or ""IO::*"" object reference" 4
.el .IP "a glob or \f(CWIO::*\fR object reference" 4
.IX Item "a glob or IO::* object reference"
Note that tied file handles are not acceptable. The underlying
libssh2 requires real file handles.
.IP "host [, port]" 4
.IX Item "host [, port]"
In order to handle IPv6 addresses the optional module
IO::Socket::IP is required.
.Sp
The port number defaults to 22.
.PP
This method used to accept a \f(CW\*(C`Timeout\*(C'\fR argument. That feature has
been replaced by the constructor \f(CW\*(C`timeout\*(C'\fR option but note that it
takes milliseconds instead of seconds!
.SS "disconnect ( [description [, reason [, language]]] )"
.IX Subsection "disconnect ( [description [, reason [, language]]] )"
Sends a clean disconnect message to the remote server. Default values are empty
strings for description and language, and \f(CW\*(C`SSH_DISCONNECT_BY_APPLICATION\*(C'\fR for
the reason.
.SS "hostname"
.IX Subsection "hostname"
The name of the remote host given at connect time or retrieved from
the \s-1TCP\s0 layer.
.SS "port"
.IX Subsection "port"
The port number of the remote \s-1SSH\s0 server.
.SS "hostkey_hash ( hash type )"
.IX Subsection "hostkey_hash ( hash type )"
Returns a hash of the host key; note that the key is raw data and may contain
nulls or control characters.
.PP
The type may be as follows:
.IP "\s-1LIBSSH2_HOSTKEY_HASH_MD5\s0" 4
.IX Item "LIBSSH2_HOSTKEY_HASH_MD5"
\&\s-1MD5\s0 hash, 16 bytes long (requires libssh2 compiled with \s-1MD5\s0 support).
.IP "\s-1LIBSSH2_HOSTKEY_HASH_SHA1\s0" 4
.IX Item "LIBSSH2_HOSTKEY_HASH_SHA1"
\&\s-1SHA1\s0 hash, 20 bytes long.
.PP
Note: in previous versions of the module this method was called
\&\f(CW\*(C`hostkey\*(C'\fR.
.SS "remote_hostkey"
.IX Subsection "remote_hostkey"
Returns the public key from the remote host and its type which is one of
\&\f(CW\*(C`LIBSSH2_HOSTKEY_TYPE_RSA\*(C'\fR, \f(CW\*(C`LIBSSH2_HOSTKEY_TYPE_DSS\*(C'\fR, or
\&\f(CW\*(C`LIBSSH2_HOSTKEY_TYPE_UNKNOWN\*(C'\fR.
.SS "check_hostkey( [policy, [known_hosts_path [, comment] ] ] )"
.IX Subsection "check_hostkey( [policy, [known_hosts_path [, comment] ] ] )"
Looks for the remote host key inside the given known host file
(defaults to \f(CW\*(C`~/.ssh/known_hosts\*(C'\fR).
.PP
On success, this method returns the result of the call done under the
hood to \f(CW\*(C`Net::SSH2::KnownHost::check\*(C'\fR
(i.e. \f(CW\*(C`LIBSSH2_KNOWNHOST_CHECK_MATCH\*(C'\fR,
\&\f(CW\*(C`LIBSSH2_KNOWNHOST_CHECK_FAILURE\*(C'\fR,
\&\f(CW\*(C`LIBSSH2_KNOWNHOST_CHECK_NOTFOUND\*(C'\fR or
\&\f(CW\*(C`LIBSSH2_KNOWNHOST_CHECK_MISMATCH\*(C'\fR).
.PP
On failure it returns \f(CW\*(C`undef\*(C'\fR.
.PP
The accepted policies are as follows:
.IP "\s-1LIBSSH2_HOSTKEY_POLICY_STRICT\s0" 4
.IX Item "LIBSSH2_HOSTKEY_POLICY_STRICT"
Only host keys already present in the known hosts file are accepted.
.Sp
This is the default policy.
.IP "\s-1LIBSSH2_HOSTKEY_POLICY_ASK\s0" 4
.IX Item "LIBSSH2_HOSTKEY_POLICY_ASK"
If the host key is not present in the known hosts file, the user is
asked if it should be accepted or not.
.Sp
If accepted, the key is added to the known host file with the given
comment.
.IP "\s-1LIBSSH2_HOSTKEY_POLICY_TOFU\s0" 4
.IX Item "LIBSSH2_HOSTKEY_POLICY_TOFU"
Trust On First Use: if the host key is not present in the known hosts
file, it is added there and accepted.
.IP "\s-1LIBSSH2_HOSTKEY_POLICY_ADVISORY\s0" 4
.IX Item "LIBSSH2_HOSTKEY_POLICY_ADVISORY"
The key is always accepted, but it is never saved into the known host
file.
.IP "callback" 4
.IX Item "callback"
If a reference to a subroutine is given, it is called when the key is
not present in the known hosts file or a different key is found. The
arguments passed to the callback are the session object, the matching
error (\f(CW\*(C`LIBSSH2_KNOWNHOST_CHECK_FAILURE\*(C'\fR,
\&\f(CW\*(C`LIBSSH2_KNOWNHOST_CHECK_NOTFOUND\*(C'\fR or
\&\f(CW\*(C`LIBSSH2_KNOWNHOST_CHECK_MISMATCH\*(C'\fR) and the comment.
.SS "auth_list ( [username] )"
.IX Subsection "auth_list ( [username] )"
Returns the authentication methods accepted by the server. In scalar
context the methods are returned as a comma separated string.
.PP
When the server accepted an unauthenticated session for the given
username, this method returns \f(CW\*(C`undef\*(C'\fR but \*(L"auth_ok\*(R" returns true.
.SS "auth_ok"
.IX Subsection "auth_ok"
Returns true when the session is authenticated.
.SS "auth_password ( username [, password [, callback ]] )"
.IX Subsection "auth_password ( username [, password [, callback ]] )"
Authenticates using a password.
.PP
If the password has expired, if a callback code reference was given, it's
called as \f(CW\*(C`callback($self, $username)\*(C'\fR and should return a password.  If
no callback is provided, \s-1LIBSSH2_ERROR_PASSWORD_EXPIRED\s0 is returned.
.SS "auth_password_interact ( username [, callback])"
.IX Subsection "auth_password_interact ( username [, callback])"
Prompts the user for the password interactively (requires
Term::ReadKey).
.SS "auth_publickey ( username, publickey_path, privatekey_path [, passphrase ] )"
.IX Subsection "auth_publickey ( username, publickey_path, privatekey_path [, passphrase ] )"
Authenticate using the given private key and an optional passphrase.
.PP
When libssh2 is compiled using OpenSSL as the crypto backend, passing
this method \f(CW\*(C`undef\*(C'\fR as the public key argument is acceptable (OpenSSL
is able to extract the public key from the private one).
.PP
See also \*(L"Supported key formats\*(R".
.SS "auth_publickey_frommemory ( username, publickey_blob, privatekey_blob [, passphrase ] )"
.IX Subsection "auth_publickey_frommemory ( username, publickey_blob, privatekey_blob [, passphrase ] )"
Authenticate using the given public/private key and an optional
passphrase. The keys must be \s-1PEM\s0 encoded (requires libssh2 1.6.0 or
later with the OpenSSL backend).
.SS "auth_hostbased ( username, publickey, privatekey, hostname, [, local username [, passphrase ]] )"
.IX Subsection "auth_hostbased ( username, publickey, privatekey, hostname, [, local username [, passphrase ]] )"
Host-based authentication using an optional passphrase. The local username
defaults to be the same as the remote username.
.SS "auth_keyboard ( username, password | callback )"
.IX Subsection "auth_keyboard ( username, password | callback )"
Authenticate using \f(CW\*(C`keyboard\-interactive\*(C'\fR. Takes either a password,
or a callback code reference which is invoked as
\&\f(CW\*(C`callback\->(self, username, name, instruction, prompt...)\*(C'\fR (where
each prompt is a hash with \f(CW\*(C`text\*(C'\fR and \f(CW\*(C`echo\*(C'\fR keys, signifying the
prompt text and whether the user input should be echoed, respectively)
which should return an array of responses.
.PP
If only a username is provided, the default callback will handle standard
interactive responses (requires Term::ReadKey)
.SS "auth_agent ( username )"
.IX Subsection "auth_agent ( username )"
Try to authenticate using an \s-1SSH\s0 agent (requires libssh2 1.2.3).
.SS "auth ( ... )"
.IX Subsection "auth ( ... )"
This is a general, prioritizing authentication mechanism that can use
any of the previous methods. You provide it some parameters and
(optionally) a ranked list of methods you want considered (defaults to
all). It will remove any unsupported methods or methods for which it
doesn't have parameters (e.g. if you don't give it a public key, it
can't use publickey or hostkey), and try the rest, returning whichever
one succeeded or \f(CW\*(C`undef\*(C'\fR if they all failed. If a parameter is passed
with an \f(CW\*(C`undef\*(C'\fR value, a default value will be supplied if possible.
.PP
The parameters are:
.IP "rank" 4
.IX Item "rank"
An optional ranked list of methods to try.  The names should be the
names of the Net::SSH2 \f(CW\*(C`auth\*(C'\fR methods, e.g. \f(CW\*(C`keyboard\*(C'\fR or
\&\f(CW\*(C`publickey\*(C'\fR, with the addition of \f(CW\*(C`keyboard\-auto\*(C'\fR for automated
\&\f(CW\*(C`keyboard\-interactive\*(C'\fR and \f(CW\*(C`password\-interact\*(C'\fR which prompts the
user for the password interactively.
.IP "username" 4
.IX Item "username"
.PD 0
.IP "password" 4
.IX Item "password"
.IP "publickey" 4
.IX Item "publickey"
.IP "privatekey" 4
.IX Item "privatekey"
.PD
\&\f(CW\*(C`privatekey\*(C'\fR and \f(CW\*(C`publickey\*(C'\fR are file paths.
.IP "passphrase" 4
.IX Item "passphrase"
.PD 0
.IP "hostname" 4
.IX Item "hostname"
.IP "local_username" 4
.IX Item "local_username"
.IP "interact" 4
.IX Item "interact"
.PD
If this option is set to a true value, interactive methods will be enabled.
.IP "fallback" 4
.IX Item "fallback"
If a password is given but authentication using it fails, the module
will fall back to ask the user for another password if this
parameter is set to a true value.
.IP "cb_keyboard" 4
.IX Item "cb_keyboard"
auth_keyboard callback.
.IP "cb_password" 4
.IX Item "cb_password"
auth_password callback.
.PP
For historical reasons and in order to maintain backward compatibility
with older versions of the module, when the \f(CW\*(C`password\*(C'\fR argument is
given, it is also used as the passphrase (and a deprecation warning
generated).
.PP
In order to avoid that behaviour the \f(CW\*(C`passphrase\*(C'\fR argument must be
also passed (it could be \f(CW\*(C`undef\*(C'\fR). For instance:
.PP
.Vb 5
\&  $ssh2\->auth(username => $user,
\&              privatekey => $privatekey_path,
\&              publickey => $publickey_path,
\&              password => $password,
\&              passphrase => undef);
.Ve
.PP
This work around will be removed in a not too distant future version
of the module.
.SS "flag (key, value)"
.IX Subsection "flag (key, value)"
Sets the given session flag.
.PP
The currently supported flag values are:
.IP "\s-1LIBSSH2_FLAG_COMPRESS\s0" 4
.IX Item "LIBSSH2_FLAG_COMPRESS"
If set before the connection negotiation is performed, compression
will be negotiated for this connection.
.Sp
Compression can also be enabled passing option \f(CW\*(C`compress\*(C'\fR to the
constructor new.
.IP "\s-1LIBSSH2_FLAG_SIGPIPE\s0" 4
.IX Item "LIBSSH2_FLAG_SIGPIPE"
if set, Net::SSH2/libssh2 will not attempt to block SIGPIPEs but will
let them trigger from the underlying socket layer.
.SS "keepalive_config(want_reply, interval)"
.IX Subsection "keepalive_config(want_reply, interval)"
Set how often keepalive messages should be sent.
.PP
\&\f(CW\*(C`want_reply\*(C'\fR indicates whether the keepalive messages should request
a response from the server. \f(CW\*(C`interval\*(C'\fR is number of seconds that can
pass without any I/O.
.SS "keepalive_send"
.IX Subsection "keepalive_send"
Send a keepalive message if needed.
.PP
On failure returns undef. On success returns how many seconds you can
sleep after this call before you need to call it again.
.PP
Note that the underlying libssh2 function \f(CW\*(C`libssh2_keepalive_send\*(C'\fR
can not recover from \s-1EAGAIN\s0 errors. If this method fails with such
error, the \s-1SSH\s0 connection may become corrupted.
.PP
The usage of this function is discouraged.
.SS "channel ( [type, [window size, [packet size]]] )"
.IX Subsection "channel ( [type, [window size, [packet size]]] )"
Creates and returns a new channel object. See Net::SSH2::Channel.
.PP
Type, if given, must be \f(CW\*(C`session\*(C'\fR (a reminiscence of an old, more
generic, but never working wrapping).
.SS "tcpip ( host, port [, shost, sport ] )"
.IX Subsection "tcpip ( host, port [, shost, sport ] )"
Creates a \s-1TCP\s0 connection from the remote host to the given host:port,
returning a new channel.
.PP
The \f(CW\*(C`shost\*(C'\fR and \f(CW\*(C`sport\*(C'\fR arguments are merely informative and passed
to the remote \s-1SSH\s0 server as the origin of the connection. They default
to 127.0.0.1:22.
.PP
Note that this method does \fBnot\fR open a new port on the local machine
and forwards incoming connections to the remote side.
.SS "listen ( port [, host [, bound port [, queue size ]]] )"
.IX Subsection "listen ( port [, host [, bound port [, queue size ]]] )"
Sets up a \s-1TCP\s0 listening port on the remote host.  Host defaults to 0.0.0.0;
if bound port is provided, it should be a scalar reference in which the bound
port is returned. Queue size specifies the maximum number of queued connections
allowed before the server refuses new connections.
.PP
Returns a new Net::SSH2::Listener object.
.SS "scp_get ( remote_path [, local_path ] )"
.IX Subsection "scp_get ( remote_path [, local_path ] )"
Retrieve a file with \s-1SCP.\s0 Local path defaults to basename of remote.
.PP
Alternatively, \f(CW\*(C`local_path\*(C'\fR may be an already open file handle or an
IO::Handle object (e.g. IO::File, IO::Scalar).
.SS "scp_put ( local_path [, remote_path ] )"
.IX Subsection "scp_put ( local_path [, remote_path ] )"
Send a file with \s-1SCP.\s0 Remote path defaults to same as local.
.PP
Alternatively, \f(CW\*(C`local_path\*(C'\fR may be an already open file handle or a
reference to a IO::Handle object (it must have a valid stat method).
.SS "sftp"
.IX Subsection "sftp"
Return SecureFTP interface object (see Net::SSH2::SFTP).
.PP
Note that \s-1SFTP\s0 support in libssh2 is pretty rudimentary. You should
consider using Net::SFTP::Foreign with the Net::SSH2 backend
Net::SFTP::Foreign::Backend::Net_SSH2 instead.
.SS "public_key"
.IX Subsection "public_key"
Return public key interface object (see Net::SSH2::PublicKey).
.SS "known_hosts"
.IX Subsection "known_hosts"
Returns known hosts interface object (see Net::SSH2::KnownHosts).
.SS "poll ( timeout, arrayref of hashes )"
.IX Subsection "poll ( timeout, arrayref of hashes )"
\&\fBDeprecated\fR: the poll functionality in libssh2 is deprecated and
its usage disregarded. Session methods \*(L"sock\*(R" and
\&\*(L"block_directions\*(R" can be used instead to integrate Net::SSH2
inside an external event loop.
.PP
Pass in a timeout in milliseconds and an arrayref of hashes with the
following keys:
.IP "handle" 4
.IX Item "handle"
May be a Net::SSH2::Channel or Net::SSH2::Listener object, integer file
descriptor, or perl file handle.
.IP "events" 4
.IX Item "events"
Requested events.  Combination of LIBSSH2_POLLFD_* constants (with the \s-1POLL\s0
prefix stripped if present), or an arrayref of the names ('in', 'hup' etc.).
.IP "revents" 4
.IX Item "revents"
Returned events.  Returns a hash with the (lowercased) names of the received
events ('in', 'hup', etc.) as keys with true values, and a \f(CW\*(C`value\*(C'\fR key with
the integer value.
.PP
Returns undef on error, or the number of active objects.
.SS "block_directions"
.IX Subsection "block_directions"
Get the blocked direction after some method returns
\&\f(CW\*(C`LIBSSH2_ERROR_EAGAIN\*(C'\fR.
.PP
Returns \f(CW\*(C`LIBSSH2_SESSION_BLOCK_INBOUND\*(C'\fR or/and
\&\f(CW\*(C`LIBSSH2_SESSION_BLOCK_OUTBOUND\*(C'\fR.
.SS "debug ( state )"
.IX Subsection "debug ( state )"
Class method (affects all Net::SSH2 objects).
.PP
Pass 1 to enable, 0 to disable. Debug output is sent to \f(CW\*(C`STDERR\*(C'\fR.
.SS "blocking ( flag )"
.IX Subsection "blocking ( flag )"
Enable or disable blocking.
.PP
A good number of the methods in \f(CW\*(C`Net::SSH2\*(C'\fR/\f(CW\*(C`libssh2\*(C'\fR can not work
in non-blocking mode. Some of them may just forcibly enable blocking
during its execution. A few may even corrupt the \s-1SSH\s0 session or crash
the program.
.PP
The ones that can be safely called are \f(CW\*(C`read\*(C'\fR and, with some
caveats, \f(CW\*(C`write\*(C'\fR. See \*(L"write\*(R" in Net::SSH2::Channel.
.PP
\&\fIDon't hesitate to report any bug you found in that area!\fR
.SH "INTEROPERABILITY AND OTHER KNOWN ISSUES"
.IX Header "INTEROPERABILITY AND OTHER KNOWN ISSUES"
.SS "Protocol versions"
.IX Subsection "Protocol versions"
The underlaying \f(CW\*(C`libssh2\*(C'\fR library does support version 2 of the \s-1SSH\s0
protocol exclusively (hopefully, version 1 usage is almost extinct).
.PP
The \s-1SFTP\s0 client implements version 3 of the \s-1SFTP\s0 protocol.
.SS "Key formats"
.IX Subsection "Key formats"
Private and public keys can be generated and stored using different
formats and cyphers. Which ones are accepted by \f(CW\*(C`Net::SSH2\*(C'\fR depends
on the libssh2 version being used and of the underlying crypto backend
(OpenSSL \f(CW\*(C`libssl\*(C'\fR or \f(CW\*(C`libgcrypt\*(C'\fR) it was
configured to use at build time.
.PP
An increassingly common problem is that OpenSSH since version 7.8
(released 2018\-8\-24) generates keys by default using the format
\&\s-1RFC4716\s0 which is not supported by \f(CW\*(C`libssl\*(C'\fR, the default crypto
backend.
.PP
Keys can be converted inplace to the old \s-1PEM\s0 format using
\&\fIssh\-keygen\fR\|(1) as follows:
.PP
.Vb 1
\&  $ ssh\-keygen \-p \-m PEM \-N "" \-f ~/.ssh/id_rsa
.Ve
.PP
On Windows, PuTTYgen (which is part of the PuTTY distribution) can be
used to convert keys.
.PP
Another common issue is that in the last years OpenSSH has
incorporated several new cyphers that are not supported by any version
of \f(CW\*(C`libssh2\*(C'\fR yet (though the incomming 1.8.1 may aliviate the
situation). Currently the best option from an interoperability
standpoint is probably to stick to \s-1RSA\s0 key usage.
.SS "Security"
.IX Subsection "Security"
Nowadays \f(CW\*(C`libssh2\*(C'\fR development is not thrilling; new versions (even
minor ones) are being released just every two or three years. On the
other hand security issues are found and reported far more
frequently. That means that \f(CW\*(C`Net::SSH2\*(C'\fR/\f(CW\*(C`libssh2\*(C'\fR could be an easy
attack vector.
.PP
So, Net::SSH2 must be used with care only in trusted environments.
.PP
More specifically, using it to connect to untrusted third party
computers over the Internet may be a very bad idea!
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Net::SSH2::Channel, Net::SSH2::Listener,
Net::SSH2::SFTP, Net::SSH2::File, Net::SSH2::Dir.
.PP
LibSSH2 documentation at <http://www.libssh2.org>.
.PP
\&\s-1IETF\s0 Secure Shell (secsh) working group at
<http://www.ietf.org/html.charters/secsh\-charter.html>.
.PP
Net::SSH::Any and Net::SFTP::Foreign integrate nicely with Net::SSH2.
.PP
Other Perl modules related to \s-1SSH\s0 you may find interesting:
Net::OpenSSH, Net::SSH::Perl, Net::OpenSSH::Parallel,
Net::OpenSSH::Compat.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2005 \- 2010 by David B. Robins (dbrobins@cpan.org).
.PP
Copyright (C) 2010 \- 2016 by Rafael Kitover (rkitover@cpan.org).
.PP
Copyright (C) 2011 \- 2019 by Salvador Fandi√±o (salva@cpan.org).
.PP
All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.0 or,
at your option, any later version of Perl 5 you may have available.
