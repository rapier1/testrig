.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Net::SSH2::File 3pm"
.TH Net::SSH2::File 3pm "2017-01-06" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::SSH2::File \- SSH2 SFTP file object
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An \s-1SFTP\s0 file object is created by the Net::SSH2::SFTP \f(CW\*(C`open\*(C'\fR method.
.SS "read ( buffer, size )"
.IX Subsection "read ( buffer, size )"
Read size bytes from the file into a given buffer.  Returns number of bytes
read, or undef on failure.
.SS "write ( buffer )"
.IX Subsection "write ( buffer )"
Write buffer to the remote file.
.PP
The \f(CW\*(C`libssh2_sftp_write\*(C'\fR function wrapped by this method has a
complex and quite difficult (if not impossible at all) to use \s-1API.\s0 It
tries to hide the packet pipelining being done under the hood in order
to attain decent throughput.
.PP
Net::SSH2 can not hide that complexity without negatively affecting
the transmission speed so it provides just a thin wrapper for that
library function.
.PP
An excerpt from \f(CW\*(C`libssh2_sftp_write\*(C'\fR manual page follows:
.PP
.Vb 1
\&  WRITE AHEAD
\&
\&  Starting in libssh2 version 1.2.8, the default behavior of libssh2
\&  is to create several smaller outgoing packets for all data you pass
\&  to this function and it will return a positive number as soon as the
\&  first packet is acknowledged from the server.
\&
\&  This has the effect that sometimes more data has been sent off but
\&  isn\*(Aqt acked yet when this function returns, and when this function
\&  is subsequently called again to write more data, libssh2 will
\&  immediately figure out that the data is already received remotely.
\&
\&  In most normal situation this should  not cause any problems, but it
\&  should be noted that if you\*(Aqve once called libssh2_sftp_write() with
\&  data and  it returns short, you  MUST still assume that  the rest of
\&  the data  might\*(Aqve been cached  so you need  to make sure  you don\*(Aqt
\&  alter that  data and think  that the version  you have in  your next
\&  function invoke will be detected or used.
\&
\&  The reason  for this funny behavior  is that SFTP can  only send 32K
\&  data in each packet and it gets all packets acked individually. This
\&  means we  cannot use a  simple serial approach  if we want  to reach
\&  high performance even on high latency connections. And we want that.
.Ve
.SS "stat"
.IX Subsection "stat"
Returns file attributes; see Net::SSH2::SFTP::stat.
.SS "setstat ( key, value... )"
.IX Subsection "setstat ( key, value... )"
Sets file attributes; see Net::SSH2::SFTP::setstat.
.SS "seek ( offset )"
.IX Subsection "seek ( offset )"
Set the file pointer offset.
.SS "tell"
.IX Subsection "tell"
Returns the current file pointer offset.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Net::SSH2::SFTP.
.PP
Check Net::SFTP::Foreign for a high level, perlish and easy to use
\&\s-1SFTP\s0 client module. It can work on top of Net::SSH2 via the
Net::SFTP::Foreign::Backend::Net_SSH2 backend module.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2005, 2006 by David B. Robins <dbrobins@cpan.org>;
.PP
Copyright (C) 2015 by Salvador Fandi√±o <sfandino@yahoo.com>;
.PP
All rights reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.0 or,
at your option, any later version of Perl 5 you may have available.
.PP
The documentation for this package contains and excerpt from libssh2
manual pages. You can consult the license of the libssh2 project for
the conditions regulating the copyright of that part.
